# TEX – Track Experience  
תוכנית פיתוח מלאה ל־Cursor IDE  
Next.js 15 (App Router) · Tailwind CSS · shadcn/ui · Supabase · Vercel · GitHub · pnpm

---

## 1. מטרת המסמך

מסמך זה מגדיר את **עקרונות הפיתוח והארכיטקטורה** של TEX (Track Experience):

- איך לבנות את המערכת מקצה לקצה בצורה נכונה, מודולרית ויציבה.
- איך לכתוב קוד כך שלא יהיה צורך ב־Refactor, אלא רק בהרחבה.
- איך Cursor וכל כלי ה־AI צריכים לפעול בתוך הפרויקט כדי לשמור על הכללים.
- איך לחייב סטנדרט אחיד בכל הקבצים, המודולים והפיצ'רים.

המסמך הוא תאורטי בלבד.  ויש להתבסס עליו לכך אורך הפיתוח מבלי לשנות אותו
---

## 2. תיאור TEX – מה האפליקציה עושה

**שם:** TEX – Track Experience (Track the Experience)

**מטרה כללית:**  
לאפשר למטיילים בעולם לבנות **מסלולי טיול חכמים ורציפים** שמשלבים:

- מקומות תיירות (אטרקציות, אתרים).
- אוכל (מסעדות, בתי קפה, אוכל רחוב).
- קניות (קניונים, שווקים, חנויות).

הכול במסלול אחד רציף:

- מנקודת התחלה לנקודת סיום.
- בהתאמה לפי **זמנים** (שעות פתיחה, משך שהייה, חלונות זמן).
- או לפי **מרחקים** (יעילות גיאוגרפית בעיר/אזור).

המערכת משתמשת ב־AI כדי:

- להבין העדפות, הגבלות ותנאים שהמשתמש מזין.
- לבנות מסלול **רב־יומי** (Trip של כמה ימים ואפילו שבועות).
- לאזן בין:
  - אטרקציות חובה.
  - אוכל וקפה.
  - קניות.
  - זמני מעבר וזמני מנוחה.

---

## 3. Stack מחייב (תאורטי)

הסטאק מחייב ואינו נתון לשינוי ללא עדכון במסמך:

- **Framework**:  
  - Next.js 15 עם App Router.

- **UI**:  
  - Tailwind CSS.
  - shadcn/ui – רכיבים מיובאים רק לפי צורך, לא חבילה מלאה מראש.

- **Backend-as-a-Service**:  
  - Supabase:
    - Database (Postgres).
    - Auth (משתמשים ותפקידי RBAC).
    - Realtime.
    - Storage (קבצים, תמונות, וכו').

- **Infra**:  
  - Vercel – הפרויקט כבר מחובר.
  - Supabase – פרויקט קיים עם אינטגרציה ל־Vercel (ENV כבר מוגדרים).

- **Repo Management**:  
  - GitHub – Repo קיים, Branch יחיד כרגע: `main`.

- **Package Manager**:  
  - pnpm – ברירת המחדל לכל התקנות וסקריפטים.

- **שפה בממשק**:  
  - כרגע – אנגלית בלבד.  
  - תכנון ל־i18n אפשרי בעתיד, אך לא ממומש בשלב הראשוני.

---

## 4. כללי זהב – פילוסופיית הפיתוח

### 4.1 מודולריות מוחלטת

1. כל Feature במערכת הוא **מודול עצמאי**.
2. כל מודול:
   - כולל בתוכו את כל מה שנחוץ כדי לתפקד מחוץ לאפליקציה:
     - לוגיקת Domain.
     - שירותי גישה לנתונים.
     - רכיבי UI ספציפיים.
     - Hooks.
     - סכמות ולידציה.
   - מאפשר שימוש בו דרך **נקודת ייצוא אחת בלבד** (קובץ `index` יחיד למודול).
3. אין תלות מעגלית בין מודולים:
   - מודול לא "מכיר" מודולים אחרים ישירות, אלא דרך ממשקים ברורים ויציבים.
   - קוד משותף מועלה ל־Core Modules.

---

### 4.2 תפקיד תיקיית `app` – שכבת Shell בלבד

תיקיית `app` אחראית על:

- הגדרת Routes (עמודים ו־Layouts).
- בניית ה־Shell של האפליקציה (Providers, Theme, Shell UI).
- הגדרת ראוטים של API.

בתיקיית `app` **אסור**:

- לוגיקה עסקית (Business Logic).
- גישה ישירה ל־Supabase או לכל DB/Service.
- ניהול State מורכב (מלבד קומפוזיציה של Hooks מהמודולים).

`app` היא שכבת תצוגה והרכבה בלבד:

- כל עמוד באפליקציה משתמש בקומפוננטות שמגיעות מהמודולים.
- כל ראוט של API משתמש ב־Use Cases/Services מתוך מודולים, ואינו מכיל לוגיקה בפני עצמו.

---

### 4.3 Core Modules – ליבה משותפת לכל האפליקציה

קיימת שכבת **Core** שמטרתה לשרת את כל המודולים מבלי להיות תלויה בהם:

- `core/config` – קונפיגורציה כללית, Environment, קבועים גלובליים.
- `core/api` – יצירת Clients, טיפול בשגיאות כלליות, חוזים ל־API.
- `core/auth` – לוגיקת Authentication & Authorization ברמת Client.
- `core/ui` – רכיבי UI גנריים שאינם קשורים לפיצ'ר ספציפי.
- `core/hooks` – Hooks כלליים (לא ספציפיים ל־Feature).
- `core/types` – טיפוסים ו־Interfaces משותפים.
- `core/utils` – פונקציות עזר כלליות.

עקרון חשוב:

- מודולים יכולים להשתמש ב־Core.
- Core לא משתמש במודולים.

---

### 4.4 אין Refactor – רק הרחבה

הקוד נכתב מראש לפי עיקרון:

> "לא נתקן, רק נוסיף."

משמעות מעשית:

- כל חוזה ציבורי (פונקציה, טיפוס, מבנה נתונים, API) מוגדר מראש כגמיש ומוכן להרחבה.
- הרחבות נעשות באמצעות:
  - מודולים חדשים.
  - פונקציות חדשות.
  - הוספת שדות אופציונליים.
- לא שוברים:
  - שמות של פונקציות קיימות.
  - שדות קיימים במבני נתונים.
  - חוזים שנצרכים על ידי חלקים אחרים בקוד.

---

### 4.5 Single Responsibility בכל הרמות

- פונקציה – אחראית על פעולה אחת ברורה.
- קובץ – מטפל בתחום אחריות יחיד (Hook אחד, Service אחד, קבוצה מוגדרת של סכמות, וכו').
- מודול – אחראי על Feature אחד ברור ומוגדר (למשל: Trip Planner, City Catalog, User Profile).

שני חוקים משלימים:

- **Rule of One** – לא מפזרים אחריות של דבר אחד בין כמה קבצים שונים.
- **Rule of Three** – כשמשהו חוזר שלוש פעמים, מוציאים אותו למקום משותף (Utility/Component/Hook/Service).

---

### 4.6 הפרדה מוחלטת בין שכבות (Separation of Concerns)

- לוגיקת Domain:
  - אינה תלויה ב־Next.js, React או UI.
  - אינה תלויה ב־Supabase באופן ישיר, אלא דרך ממשקי גישה מופשטים.

- UI:
  - אינו ניגש ישירות ל־Supabase או ל־API חיצוניים.
  - משתמש ב־Hooks/Services המוגדרים במודולים או ב־Core.

- Services:
  - אחראיים על גישה לנתונים (Supabase, API).
  - מחוברים ללוגיקת Domain באופן ברור ומוגן.

---

### 4.7 TypeScript ו־Validation

- הפרויקט מוגדר עם TypeScript במצב מחמיר:
  - Strict Types.
  - שימוש בטיפוסים ברורים לכל חלק לוגי.
- ולידציה:
  - קיימת ברמת API (קלט/פלט).
  - קיימת ברמת UI (טפסים, אינפוט מהמשתמש).
- טיפוסים מוגדרים כבסיס ל־Contracts יציבים בין שכבות.

---

### 4.8 סטנדרט קוד גלובלי

- ייצוא שמותי (Named Exports) בלבד – ללא Default Exports.
- שימוש ב־ESLint לצורך:
  - מניעת משתנים לא בשימוש.
  - מניעת טיפוסי `any` לא מבוקרים.
  - חוקים לסגנון ולקריאות.
- שימוש ב־Prettier לצורך פורמט אחיד:
  - רווחים, פסיקים, גרשיים, וכו'.

---

### 4.9 עבודה עם Cursor ו־AI בפרויקט TEX

בעת שימוש ב־Cursor או כל כלי AI:

1. חובה לציין בכל בקשה:
   - האם השינוי שייך ל־Core או למודול ספציפי.
   - שם המודול (אם זה Feature).

2. כל קוד שמוצע:
   - חייב להיות ממוקם במודול הנכון, לפי העקרונות שבמסמך.
   - חייב לשמור על הפרדה בין:
     - UI.
     - Services.
     - Domain.
     - Core.

3. הצעות קוד שמפרות את הכללים:
   - לדוגמה: גישה ל־Supabase מתוך Component, Business Logic ב־`app` – **לא מתקבלות**.
   - יש לנסח מחדש את הבקשה ל־Cursor כך שהיא תכבד את הארכיטקטורה.

---

## 5. מבנה לוגי של תיקיות ומודולים (ברמת רעיון בלבד)

> חלק זה מתאר *איך* צריך להיראות הארגון, בלי להגדיר קובצי קוד ספציפיים או שמות פונקציות.

- קיימת שכבת `app`:
  - מכילה עמודים, Layouts ו־Routes ל־API.
  - אחראית על הגדרת מסלולים כמו:
    - דף בית.
    - רשימת Trips.
    - Trip יחיד.
    - פרופיל משתמש.
    - דפים עירוניים.

- קיימת שכבת `core`:
  - אחראית על תשתיות משותפות (Auth, API, UI בסיסי, Config וכו').

- קיימת שכבת `modules`:
  - מופרדת למודולים לפי Features, כדוגמת:
    - מודול לניהול Trips.
    - מודול לקטלוג ערים ומקומות.
    - מודול לפרופיל משתמש.
    - מודול לשימוש ב־AI לצורך תכנון מסלולים.

כל מודול:

- מכיל בתוכו:
  - לוגיקת Domain.
  - שירותי גישה לנתונים.
  - Hooks פנימיים.
  - רכיבי UI הנוגעים דווקא לפיצ'ר שלו.
  - סכמות ולידציה הקשורות אליו.

- מייצא כלפי חוץ:
  - רכיבים ו־Hooks שנועדו לשימוש מ־`app` או ממודולים אחרים.
  - דרך נקודת ייצוא מרכזית אחת.

---

## 6. מודולי ליבה ראשוניים (Core) – תאורטי

בהגדרה הראשונית, TEX מצריך לפחות את מודולי הליבה הבאים:

1. מודול Config:
   - אחראי לקריאת משתני סביבה.
   - מגדיר קבועים גלובליים (שמות אפליקציה, גרסה, ועוד).

2. מודול API:
   - אחראי על יצירת Clients חיצוניים (Supabase, HTTP).
   - אחראי על טיפול בשגיאות ברמת תשתית.

3. מודול Auth:
   - מטפל בזהות המשתמש.
   - מנהל הרשאות ותפקידים (RBAC) בצד הלקוח.

4. מודול UI:
   - מרכיב ספריית UI בסיסית משותפת לכל האפליקציה:
     - כפתורים.
     - אינפוטים.
     - Layoutים בסיסיים.
     - טיפוגרפיה.

5. מודול Hooks:
   - מכיל Hooks כלליים שלא שייכים לפיצ'ר ספציפי (למשל: Hook למדיה, Hook לדיליי וכו').

---

## 7. מודולי Feature ראשוניים (תכנון ברמת רעיון)

ברמת רעיון בלבד, האפליקציה תיבנה סביב מספר מודולי Feature עיקריים:

1. מודול Trip Planner:
   - אחראי להגדרה, עריכה ואופטימיזציה של מסלולי טיול.
   - מנהל חלוקה לימים, חלונות זמן, מקומות בכל יום וכו'.

2. מודול City Catalog:
   - מנהל מידע על ערים, אזורים ומקומות בתוך כל עיר (אוכל, אטרקציות, קניות).

3. מודול User Profile:
   - מנהל מידע על המשתמש, העדפות טיול, Trips שמורים, היסטוריה.

4. מודול AI Planner:
   - אחראי לתקשורת עם מודל ה־AI.
   - מתאם בין נתוני המשתמש, קטלוג העיר, והצעת המסלול.

5. מודולים נוספים בעתיד:
   - מנגנון שיתופים.
   - שיתוף Trips.
   - תזכורות, התראות וכו'.

---

<!-- כאן מסתיים החלק התאורטי של TEX.md.
מכאן והלאה – מימוש טכני צעד־אחר־צעד, בקובץ TASKS.md
